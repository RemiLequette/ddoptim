# Claude Code Instructions for DDoptim Project

## Project Context
This is DDoptim - a DDMRP buffer positioning optimizer for supply chain networks.
Based on the Weber Pignons bicycle assembly case study (Grenoble, France).

## Package Management - IMPORTANT
**Always use `uv` for package management:**
- Use `pyproject.toml` for dependencies (NOT requirements.txt)
- Commands:
  - `uv add <package>` to add dependencies
  - `uv sync` to sync environment
  - `uv run <command>` to run in the virtual environment
  - `uv pip install <package>` if needed for specific cases

## Python Environment
- Python 3.11+
- Virtual environment managed by uv (stored in .venv/)
- Main dependencies: networkx, dash, plotly, dash-bootstrap-components

## Code Style Preferences
- **Type hints**: Use type hints for function signatures
- **Docstrings**: Google-style docstrings for all public functions/classes
- **Imports**: Group by standard library, third-party, local (with blank lines between)
- **Line length**: 100 characters max
- **Naming**: 
  - snake_case for functions/variables
  - PascalCase for classes
  - UPPER_CASE for constants

## Project Structure
```
ddoptim/
â”œâ”€â”€ core/           # Core data structures (BufferProfile, NetworkNode, Network)
â”œâ”€â”€ tests/          # Test suite
â”œâ”€â”€ examples/       # Example networks (Weber Pignons)
â”œâ”€â”€ visualization/  # Interactive web-based viewer
â”œâ”€â”€ data/           # Network JSON files
â””â”€â”€ pyproject.toml  # Project config and dependencies
```

## Development Workflow
1. Always run tests before committing: `uv run python tests/test_core_simple.py`
2. Validate networks before saving: `network.validate()`
3. Use the visualization tool to verify changes: `uv run python visualization/network_viewer.py`
4. Document new features in appropriate README files

## Key Technical Decisions
- **NetworkX** for graph operations (DAG structure)
- **Dataclasses** for data structures (with validation in __post_init__)
- **JSON serialization** for save/load (to_dict/from_dict methods)
- **Three-tier optimization**: Hard constraints â†’ Mandatory buffers + Inventory optimization â†’ Scenario analysis
- **All data mandatory** for MVP (no defaults)
- **Single-location model** (no distribution networks)

## DDMRP Methodology
- Buffer profiles: F (Finished), I (Intermediate), U (Machined), AL (Local), AI (International)
- Three-tier prioritization framework for buffer positioning
- Primary optimization objective: Minimize total inventory value
- Buffer sizing: Yellow (ADU Ã— DLT), Green (order size), Red (safety stock)

## Testing
- Test file: `tests/test_core_simple.py`
- Run: `uv run python tests/test_core_simple.py`
- All core functionality must have tests
- Validate networks before using them

## When Adding New Features
1. Check requirements document: `PROJECT_SUMMARY.md`
2. Update relevant module in core/
3. Add tests
4. Update documentation
5. Test with Weber Pignons network
6. Update visualization if needed

## Common Commands
```bash
# Add a dependency
uv add <package>

# Run tests
uv run python tests/test_core_simple.py

# Build Weber Pignons network
uv run python examples/create_weber_pignons.py

# Launch visualization
uv run python visualization/network_viewer.py

# Run any Python script
uv run python <script.py>
```

## Reference Documents
- `PROJECT_SUMMARY.md` - Quick reference for requirements
- `DDoptim_requirements.md` - Full detailed requirements (in project root if available)
- Weber Pignons case study PDF - Reference for validation
- Excel calculations - Buffer sizing formulas

## Current Phase
Phase 2: Core Implementation
- âœ… Core data structures complete
- âœ… Weber Pignons network complete
- âœ… Visualization tool complete
- ðŸ”„ Next: ADU propagation, DLT calculation, buffer sizing

## Important Notes
- Never use defaults for data - all fields mandatory for MVP
- Always validate networks before operations
- Buffer profiles are configurable (Weber Pignons profiles as defaults)
- Network must be a DAG (directed acyclic graph) - cycles are detected and prevented
- Multi-product support: each product modeled separately, shared components via ADU aggregation

## Code Quality Standards
- Prefer explicit over implicit
- Fail fast with clear error messages
- Document why, not what (code shows what)
- Keep functions focused (single responsibility)
- Use descriptive variable names
- Validate inputs early

## Git Workflow
- Commit working features incrementally
- Write descriptive commit messages
- Test before committing
- Keep commits focused on single changes

## Performance Considerations
- Networks with < 100 nodes: No optimization needed
- For larger networks: Consider layout caching, lazy evaluation
- Validation is cheap, always validate before operations

## Remember
- This is a research/prototyping tool, not production software
- Clarity and correctness over performance
- Extensive documentation over minimal comments
- Testability over cleverness
